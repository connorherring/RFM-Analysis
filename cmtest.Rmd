---
title: "RFM Analysis"
output: word_document
---

```{r warning=FALSE, message=FALSE}
library(plyr)
library(dplyr)
library(ggplot2)
library(RColorBrewer)
library(data.table)
library(scales)

setwd("C:/Users/cherring/Documents")
```

## __Data Ingestion and Transformations__

```{r warning=FALSE, message=FALSE}
data <- read.csv("train_clubmahindra.csv")
data <- data[c(1,2,7,8,13,14,15,18,20,24)]
data$booking_date <- as.character(data$booking_date)
data$booking_date <-as.POSIXct(data$booking_date, format = "%d/%m/%y")

# Subset to 2017
data <- data[substr(data$booking_date,1,4) == "2017",]

# Calculate Total Amount Spent 
data$total_amount_spent <- data$amount_spent_per_room_night_scaled * 100 * data$roomnights

# Initialize customer data frame
customers <- as.data.frame(unique(data$memberid))
names(customers) <- "memberid"
```


## __Recency__

```{r warning=FALSE, message=FALSE}
# Calculate number of days since booking date
data$recency <- as.Date("2018-01-01") - as.Date(data$booking_date)

# Obtain number of days since most recent booking
data = data.table(data)
recency = data[,list(recency=min(recency)),by = 'memberid']

# Add recency to customer data
customers <- merge(customers, recency, by="memberid", all=TRUE, sort=TRUE)
remove(recency)
customers$recency <- as.numeric(customers$recency)
```


## __Frequency__

```{r warning=FALSE, message=FALSE}
# Obtain list of distinct invoices by customer
customer.invoices <- subset(data, select = c("memberid","reservation_id"))
customer.invoices <- customer.invoices[!duplicated(customer.invoices), ]
customer.invoices <- customer.invoices[order(customer.invoices$memberid),]
row.names(customer.invoices) <- NULL
customer.invoices$rescount <- 1

# Calculate frequency by taking sum of distinct invoices
frequency = customer.invoices[,list(frequency=sum(rescount)),by = 'memberid']

# Add frequency to customer data
customers <- merge(customers, frequency, by="memberid", all=TRUE, sort=TRUE)
remove(frequency)
customers$frequency <- as.numeric(customers$frequency)
```


## __Monetary__

```{r warning=FALSE, message=FALSE}
# Calculate monetary by taking sum of total amounts
monetary = data[,list(monetary=sum(total_amount_spent)),by = 'memberid']

# Add monetary value to customers dataset
customers <- merge(customers, monetary, by="memberid", all.x=TRUE, sort=TRUE)
remove(monetary)
customers$monetary <- as.numeric(customers$monetary)
```


#### Apply Pareto Principle (80/20 rule)
```{r warning=FALSE, message=FALSE}
pareto.cutoff <- 0.8 * sum(customers$monetary)
customers$pareto <- ifelse(cumsum(customers$monetary) <= pareto.cutoff, "Top 20%", "Bottom 80%")
customers$pareto <- factor(customers$pareto, levels=c("Top 20%", "Bottom 80%"), ordered=TRUE)
levels(customers$pareto)
```

## __Scatter Plots__

#### Raw Values

```{r warning=FALSE, message=FALSE}
scatter.1 <- ggplot(customers, aes(x = frequency, y = monetary))
scatter.1 <- scatter.1 + geom_point(aes(colour = recency, shape = pareto))
scatter.1 <- scatter.1 + scale_shape_manual(name = "80/20 Designation", values=c(17, 16))
scatter.1 <- scatter.1 + scale_colour_gradient(name="Recency\n(Days since Last Booking)")
scatter.1 <- scatter.1 + scale_y_continuous(label=dollar)
scatter.1 <- scatter.1 + xlab("Frequency (Number of Bookings)")
scatter.1 <- scatter.1 + ylab("Monetary Value of Customer (Annual Sales)")
scatter.1
```

#### Log-transformed Values 

```{r warning=FALSE, message=FALSE}
scatter.1 <- ggplot(customers, aes(x = log(frequency), y = log(monetary)))
scatter.1 <- scatter.1 + geom_point(aes(colour = log(recency), shape = pareto))
scatter.1 <- scatter.1 + scale_shape_manual(name = "80/20 Designation", values=c(17, 16))
scatter.1 <- scatter.1 + scale_colour_gradient(name="Log-transformed Recency")
scatter.1 <- scatter.1 + scale_y_continuous(label=dollar)
scatter.1 <- scatter.1 + xlab("Log-transformed Frequency")
scatter.1 <- scatter.1 + ylab("Log-transformed Monetary Value of Customer")
scatter.1
```

## __Modeling__

#### Test number of clusters

```{r warning=FALSE, message=FALSE}
preprocessed <- customers[c(2:4)]
j <- 10 # maximum number of clusters

# Initiate model dataframe
models <- data.frame(k=integer(),
                     tot.withinss=numeric(),
                     betweenss=numeric(),
                     totss=numeric(),
                     rsquared=numeric())

# Add cluster membership to customers dataset
for (k in 1:j ) {
  
  print(k)
  
  # Run kmeans
  output <- kmeans(preprocessed, centers = k, nstart = 20)
  
  # Add cluster membership to customers dataset
  var.name <- paste("cluster", k, sep="_")
  customers[,(var.name)] <- output$cluster
  customers[,(var.name)] <- factor(customers[,(var.name)], levels = c(1:k))
  
  # Graph clusters
  cluster_graph <- ggplot(customers, aes(x = log(frequency), y = log(monetary)))
  cluster_graph <- cluster_graph + geom_point(aes(colour = customers[,(var.name)]))
  colors <- c('red','orange','green3','deepskyblue','blue','darkorchid4','violet','pink1','tan3','black')
  cluster_graph <- cluster_graph + scale_colour_manual(name = "Cluster Group", values=colors)
  cluster_graph <- cluster_graph + xlab("Log-transformed Frequency")
  cluster_graph <- cluster_graph + ylab("Log-transformed Monetary Value of Customer")
  title <- paste("k-means Solution with", k, sep=" ")
  title <- paste(title, "Clusters", sep=" ")
  cluster_graph <- cluster_graph + ggtitle(title)
  print(cluster_graph)
  
  # Cluster centers in original metrics
  print(title)
  cluster_centers <- ddply(customers, .(customers[,(var.name)]), summarize,
                           monetary=round(median(monetary),2),                      frequency=round(median(frequency),1),
                           recency=round(median(recency), 0))
  names(cluster_centers)[names(cluster_centers)=="customers[, (var.name)]"] <- "Cluster"
  print(cluster_centers)
  cat("\n")
    
  # Collect model information
  models[k,("k")] <- k
  models[k,("tot.withinss")] <- output$tot.withinss 
  models[k,("betweenss")] <- output$betweenss
  models[k,("totss")] <- output$totss 
  models[k,("rsquared")] <- round(output$betweenss/output$totss, 3)    
  assign("models", models, envir = .GlobalEnv)
  remove(output, var.name, cluster_graph, cluster_centers, title, colors)
}

# Use NBClust to determine optimal number of clusters 
library(NbClust)
set.seed(1)
nc <- NbClust(preprocessed[sample(nrow(preprocessed), 1000),], min.nc=2, max.nc=7, method="kmeans")

barplot(table(nc$Best.n[1,]),
        xlab="Number of Clusters", ylab="Number of Criteria",
        main="Number of Clusters Chosen by Criteria",
        cex.axis = .8,
        cex.names = .8)
```




